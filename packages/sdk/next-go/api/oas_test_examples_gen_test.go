// Code generated by ogen, DO NOT EDIT.

package api

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAgentPart_EncodeDecode(t *testing.T) {
	var typ AgentPart
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AgentPart
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAgentPartInput_EncodeDecode(t *testing.T) {
	var typ AgentPartInput
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AgentPartInput
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAgentPartInputSource_EncodeDecode(t *testing.T) {
	var typ AgentPartInputSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AgentPartInputSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAgentPartSource_EncodeDecode(t *testing.T) {
	var typ AgentPartSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AgentPartSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestApiAuth_EncodeDecode(t *testing.T) {
	var typ ApiAuth
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ApiAuth
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppLogReq_EncodeDecode(t *testing.T) {
	var typ AppLogReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppLogReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppLogReqExtra_EncodeDecode(t *testing.T) {
	var typ AppLogReqExtra
	typ = make(AppLogReqExtra)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppLogReqExtra
	typ2 = make(AppLogReqExtra)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppLogReqLevel_EncodeDecode(t *testing.T) {
	var typ AppLogReqLevel
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppLogReqLevel
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAssistantMessage_EncodeDecode(t *testing.T) {
	var typ AssistantMessage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AssistantMessage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAssistantMessageError_EncodeDecode(t *testing.T) {
	var typ AssistantMessageError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AssistantMessageError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAssistantMessagePath_EncodeDecode(t *testing.T) {
	var typ AssistantMessagePath
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AssistantMessagePath
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAssistantMessageTime_EncodeDecode(t *testing.T) {
	var typ AssistantMessageTime
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AssistantMessageTime
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAssistantMessageTokens_EncodeDecode(t *testing.T) {
	var typ AssistantMessageTokens
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AssistantMessageTokens
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAssistantMessageTokensCache_EncodeDecode(t *testing.T) {
	var typ AssistantMessageTokensCache
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AssistantMessageTokensCache
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuth_EncodeDecode(t *testing.T) {
	var typ Auth
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Auth
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuthSetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ AuthSetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthSetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCommand_EncodeDecode(t *testing.T) {
	var typ Command
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Command
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConfigProvidersOK_EncodeDecode(t *testing.T) {
	var typ ConfigProvidersOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConfigProvidersOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConfigProvidersOKDefault_EncodeDecode(t *testing.T) {
	var typ ConfigProvidersOKDefault
	typ = make(ConfigProvidersOKDefault)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConfigProvidersOKDefault
	typ2 = make(ConfigProvidersOKDefault)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError_EncodeDecode(t *testing.T) {
	var typ Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestErrorData_EncodeDecode(t *testing.T) {
	var typ ErrorData
	typ = make(ErrorData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ErrorData
	typ2 = make(ErrorData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFile_EncodeDecode(t *testing.T) {
	var typ File
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 File
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFileNode_EncodeDecode(t *testing.T) {
	var typ FileNode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FileNode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFileNodeType_EncodeDecode(t *testing.T) {
	var typ FileNodeType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FileNodeType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFilePart_EncodeDecode(t *testing.T) {
	var typ FilePart
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FilePart
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFilePartInput_EncodeDecode(t *testing.T) {
	var typ FilePartInput
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FilePartInput
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFilePartSource_EncodeDecode(t *testing.T) {
	var typ FilePartSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FilePartSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFilePartSourceText_EncodeDecode(t *testing.T) {
	var typ FilePartSourceText
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FilePartSourceText
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFileReadOK_EncodeDecode(t *testing.T) {
	var typ FileReadOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FileReadOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFileReadOKType_EncodeDecode(t *testing.T) {
	var typ FileReadOKType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FileReadOKType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFileSource_EncodeDecode(t *testing.T) {
	var typ FileSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FileSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFileStatus_EncodeDecode(t *testing.T) {
	var typ FileStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FileStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFindTextOKItem_EncodeDecode(t *testing.T) {
	var typ FindTextOKItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FindTextOKItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFindTextOKItemLines_EncodeDecode(t *testing.T) {
	var typ FindTextOKItemLines
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FindTextOKItemLines
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFindTextOKItemPath_EncodeDecode(t *testing.T) {
	var typ FindTextOKItemPath
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FindTextOKItemPath
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFindTextOKItemSubmatchesItem_EncodeDecode(t *testing.T) {
	var typ FindTextOKItemSubmatchesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FindTextOKItemSubmatchesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFindTextOKItemSubmatchesItemMatch_EncodeDecode(t *testing.T) {
	var typ FindTextOKItemSubmatchesItemMatch
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FindTextOKItemSubmatchesItemMatch
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHealthGetOK_EncodeDecode(t *testing.T) {
	var typ HealthGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HealthGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHealthGetOKMemory_EncodeDecode(t *testing.T) {
	var typ HealthGetOKMemory
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HealthGetOKMemory
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMessage_EncodeDecode(t *testing.T) {
	var typ Message
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Message
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMessageAbortedError_EncodeDecode(t *testing.T) {
	var typ MessageAbortedError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MessageAbortedError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMessageAbortedErrorData_EncodeDecode(t *testing.T) {
	var typ MessageAbortedErrorData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MessageAbortedErrorData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMessageOutputLengthError_EncodeDecode(t *testing.T) {
	var typ MessageOutputLengthError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MessageOutputLengthError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMessageOutputLengthErrorData_EncodeDecode(t *testing.T) {
	var typ MessageOutputLengthErrorData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MessageOutputLengthErrorData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestModel_EncodeDecode(t *testing.T) {
	var typ Model
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Model
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestModelCost_EncodeDecode(t *testing.T) {
	var typ ModelCost
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ModelCost
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestModelLimit_EncodeDecode(t *testing.T) {
	var typ ModelLimit
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ModelLimit
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestModelOptions_EncodeDecode(t *testing.T) {
	var typ ModelOptions
	typ = make(ModelOptions)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ModelOptions
	typ2 = make(ModelOptions)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuth_EncodeDecode(t *testing.T) {
	var typ OAuth
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuth
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPart_EncodeDecode(t *testing.T) {
	var typ Part
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Part
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPart_EncodeDecode(t *testing.T) {
	var typ PatchPart
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPart
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPath_EncodeDecode(t *testing.T) {
	var typ Path
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Path
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostSessionByIdPermissionsByPermissionIDReq_EncodeDecode(t *testing.T) {
	var typ PostSessionByIdPermissionsByPermissionIDReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostSessionByIdPermissionsByPermissionIDReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostSessionByIdPermissionsByPermissionIDReqResponse_EncodeDecode(t *testing.T) {
	var typ PostSessionByIdPermissionsByPermissionIDReqResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostSessionByIdPermissionsByPermissionIDReqResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProject_EncodeDecode(t *testing.T) {
	var typ Project
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Project
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectTime_EncodeDecode(t *testing.T) {
	var typ ProjectTime
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectTime
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProvider_EncodeDecode(t *testing.T) {
	var typ Provider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Provider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProviderAuthError_EncodeDecode(t *testing.T) {
	var typ ProviderAuthError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProviderAuthError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProviderAuthErrorData_EncodeDecode(t *testing.T) {
	var typ ProviderAuthErrorData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProviderAuthErrorData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProviderModels_EncodeDecode(t *testing.T) {
	var typ ProviderModels
	typ = make(ProviderModels)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProviderModels
	typ2 = make(ProviderModels)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRange_EncodeDecode(t *testing.T) {
	var typ Range
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Range
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRangeEnd_EncodeDecode(t *testing.T) {
	var typ RangeEnd
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RangeEnd
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRangeStart_EncodeDecode(t *testing.T) {
	var typ RangeStart
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RangeStart
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReasoningPart_EncodeDecode(t *testing.T) {
	var typ ReasoningPart
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReasoningPart
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReasoningPartMetadata_EncodeDecode(t *testing.T) {
	var typ ReasoningPartMetadata
	typ = make(ReasoningPartMetadata)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReasoningPartMetadata
	typ2 = make(ReasoningPartMetadata)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReasoningPartTime_EncodeDecode(t *testing.T) {
	var typ ReasoningPartTime
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReasoningPartTime
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSession_EncodeDecode(t *testing.T) {
	var typ Session
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Session
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionCommandOK_EncodeDecode(t *testing.T) {
	var typ SessionCommandOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionCommandOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionCommandReq_EncodeDecode(t *testing.T) {
	var typ SessionCommandReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionCommandReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionCreateReq_EncodeDecode(t *testing.T) {
	var typ SessionCreateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionCreateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionInitReq_EncodeDecode(t *testing.T) {
	var typ SessionInitReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionInitReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionMessageOK_EncodeDecode(t *testing.T) {
	var typ SessionMessageOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionMessageOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionMessagesOKItem_EncodeDecode(t *testing.T) {
	var typ SessionMessagesOKItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionMessagesOKItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionPromptOK_EncodeDecode(t *testing.T) {
	var typ SessionPromptOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionPromptOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionPromptReq_EncodeDecode(t *testing.T) {
	var typ SessionPromptReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionPromptReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionPromptReqModel_EncodeDecode(t *testing.T) {
	var typ SessionPromptReqModel
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionPromptReqModel
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionPromptReqPartsItem_EncodeDecode(t *testing.T) {
	var typ SessionPromptReqPartsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionPromptReqPartsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionPromptReqTools_EncodeDecode(t *testing.T) {
	var typ SessionPromptReqTools
	typ = make(SessionPromptReqTools)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionPromptReqTools
	typ2 = make(SessionPromptReqTools)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionRevert_EncodeDecode(t *testing.T) {
	var typ SessionRevert
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionRevert
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionRevertReq_EncodeDecode(t *testing.T) {
	var typ SessionRevertReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionRevertReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionShare_EncodeDecode(t *testing.T) {
	var typ SessionShare
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionShare
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionShellReq_EncodeDecode(t *testing.T) {
	var typ SessionShellReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionShellReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionSummarizeReq_EncodeDecode(t *testing.T) {
	var typ SessionSummarizeReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionSummarizeReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionTime_EncodeDecode(t *testing.T) {
	var typ SessionTime
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionTime
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionUpdateReq_EncodeDecode(t *testing.T) {
	var typ SessionUpdateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionUpdateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSnapshotPart_EncodeDecode(t *testing.T) {
	var typ SnapshotPart
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SnapshotPart
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStepFinishPart_EncodeDecode(t *testing.T) {
	var typ StepFinishPart
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StepFinishPart
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStepFinishPartTokens_EncodeDecode(t *testing.T) {
	var typ StepFinishPartTokens
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StepFinishPartTokens
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStepFinishPartTokensCache_EncodeDecode(t *testing.T) {
	var typ StepFinishPartTokensCache
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StepFinishPartTokensCache
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStepStartPart_EncodeDecode(t *testing.T) {
	var typ StepStartPart
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StepStartPart
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSymbol_EncodeDecode(t *testing.T) {
	var typ Symbol
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Symbol
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSymbolLocation_EncodeDecode(t *testing.T) {
	var typ SymbolLocation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SymbolLocation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSymbolSource_EncodeDecode(t *testing.T) {
	var typ SymbolSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SymbolSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTextPart_EncodeDecode(t *testing.T) {
	var typ TextPart
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TextPart
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTextPartInput_EncodeDecode(t *testing.T) {
	var typ TextPartInput
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TextPartInput
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTextPartInputTime_EncodeDecode(t *testing.T) {
	var typ TextPartInputTime
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TextPartInputTime
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTextPartTime_EncodeDecode(t *testing.T) {
	var typ TextPartTime
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TextPartTime
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestToolPart_EncodeDecode(t *testing.T) {
	var typ ToolPart
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ToolPart
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestToolState_EncodeDecode(t *testing.T) {
	var typ ToolState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ToolState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestToolStateCompleted_EncodeDecode(t *testing.T) {
	var typ ToolStateCompleted
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ToolStateCompleted
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestToolStateCompletedInput_EncodeDecode(t *testing.T) {
	var typ ToolStateCompletedInput
	typ = make(ToolStateCompletedInput)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ToolStateCompletedInput
	typ2 = make(ToolStateCompletedInput)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestToolStateCompletedMetadata_EncodeDecode(t *testing.T) {
	var typ ToolStateCompletedMetadata
	typ = make(ToolStateCompletedMetadata)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ToolStateCompletedMetadata
	typ2 = make(ToolStateCompletedMetadata)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestToolStateCompletedTime_EncodeDecode(t *testing.T) {
	var typ ToolStateCompletedTime
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ToolStateCompletedTime
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestToolStateError_EncodeDecode(t *testing.T) {
	var typ ToolStateError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ToolStateError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestToolStateErrorInput_EncodeDecode(t *testing.T) {
	var typ ToolStateErrorInput
	typ = make(ToolStateErrorInput)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ToolStateErrorInput
	typ2 = make(ToolStateErrorInput)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestToolStateErrorMetadata_EncodeDecode(t *testing.T) {
	var typ ToolStateErrorMetadata
	typ = make(ToolStateErrorMetadata)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ToolStateErrorMetadata
	typ2 = make(ToolStateErrorMetadata)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestToolStateErrorTime_EncodeDecode(t *testing.T) {
	var typ ToolStateErrorTime
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ToolStateErrorTime
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestToolStatePending_EncodeDecode(t *testing.T) {
	var typ ToolStatePending
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ToolStatePending
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestToolStateRunning_EncodeDecode(t *testing.T) {
	var typ ToolStateRunning
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ToolStateRunning
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestToolStateRunningMetadata_EncodeDecode(t *testing.T) {
	var typ ToolStateRunningMetadata
	typ = make(ToolStateRunningMetadata)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ToolStateRunningMetadata
	typ2 = make(ToolStateRunningMetadata)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestToolStateRunningTime_EncodeDecode(t *testing.T) {
	var typ ToolStateRunningTime
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ToolStateRunningTime
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTuiAppendPromptReq_EncodeDecode(t *testing.T) {
	var typ TuiAppendPromptReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TuiAppendPromptReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTuiExecuteCommandReq_EncodeDecode(t *testing.T) {
	var typ TuiExecuteCommandReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TuiExecuteCommandReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTuiShowToastReq_EncodeDecode(t *testing.T) {
	var typ TuiShowToastReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TuiShowToastReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTuiShowToastReqVariant_EncodeDecode(t *testing.T) {
	var typ TuiShowToastReqVariant
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TuiShowToastReqVariant
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnknownError_EncodeDecode(t *testing.T) {
	var typ UnknownError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UnknownError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnknownErrorData_EncodeDecode(t *testing.T) {
	var typ UnknownErrorData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UnknownErrorData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserMessage_EncodeDecode(t *testing.T) {
	var typ UserMessage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserMessage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserMessageTime_EncodeDecode(t *testing.T) {
	var typ UserMessageTime
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserMessageTime
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWellKnownAuth_EncodeDecode(t *testing.T) {
	var typ WellKnownAuth
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WellKnownAuth
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
