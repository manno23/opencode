# OpenCode Go SDK (next-go)

This SDK provides a Go client for the OpenCode API.

## Generating the Client

To regenerate the client, run the following script from this directory:

```bash
./scripts/generate.sh
```

## Testing

The SDK includes comprehensive tests to ensure proper functionality and track API coverage. Tests are organized in a dedicated `test/` directory.

### Running Tests

To run all tests:

```bash
./scripts/test.sh
```

Or run directly with Go:

```bash
go test -v ./test/...
```

### Test Structure

All tests are located in the `test/` directory:

1. **Unit Tests** (`test/opencode_test.go`) - Tests for individual SDK functions
2. **Integration Tests** (`test/integration_test.go`) - Tests that run against a live or mock server
3. **Coverage Tracking** (`test/coverage_test.go`) - Tools to track API implementation and test coverage

### Coverage Reports

The test suite generates coverage reports to track:

- Which API endpoints have been implemented
- Which API endpoints have been tested
- Overall API coverage percentage

Reports are saved to `coverage.html` and `coverage_report.json`.

## Internal

This SDK's API is generated by the opencode project at @packages/opencode.
The OpenAPI spec is generated from the reflective hono + zod libraries in
server endpoint code.
When a new version is built, a github action checks the produced API spec
for differences, and if so, it is fed back to this generator to create the
SDK's before building the dependencies that opencode itself has.

The server, and all other packages, are built from the root via

```bash
  $ bun run dev
```

If that works well, the generated API SDK's can be generated via

```bash
  $ bun run generate
```

## Integration Pattern

The recommended integration pattern is to wrap the generated client via composition in the `opencode.go` file. This approach allows for extending the client's functionality without directly modifying the generated code in the `api/` directory, which should be treated as an artifact.


# Unique Benefits of Ogen Over Other Go Generators



```.ogen.yml
generator:
  features:
    disable_all: true  # Start fresh, enable selectively
    enable:
      - "paths/client"               # Generate client code
      - "paths/server"               # Generate server code
      - "client/request/validation"  # Enable request validation
      - "server/response/validation" # Enable response validation
      - "ogen/otel"                  # OpenTelemetry integration
  infer_types: true                  # Auto-infer schema types
```






```
// Custom adapter wrapping the generated client.

package adapters

import (
	"context"
	"log"

	"yourproject/api"
)

type ClientAdapter struct {
	client *api.Client
}

func NewClientAdapter(baseURL string) (*ClientAdapter, error) {
	cl, err := api.NewClient(baseURL, api.WithHTTPClient(http.DefaultClient))
	if err != nil {
		return nil, err
	}
	return &ClientAdapter{client: cl}, nil
}

func (a *ClientAdapter) GetPetWithLogging(ctx context.Context, id int64) (api.CustomPet, error) {
	log.Printf("Fetching pet with ID: %d", id)
	params := api.GetPetParams{ID: id}
	pet, err := a.client.GetPet(ctx, params)
	if err != nil {
		log.Printf("Error: %v", err)
	}
	return pet, err
}

// Extend for auth, retries, etc.
```


- adapters/server_handler_impl.go
```
package adapters

import (
	"context"
	"io"
	"net/http"
	"yourproject/api"
)

type MyHandler struct {
	// Dependencies like DB...
}

func (h *MyHandler) GetPet(ctx context.Context, params api.GetPetParams) (api.CustomPet, error) {
	// Business logic: Fetch from DB...
	return api.CustomPet{Name: "Fluffy", Age: 5}, nil
}

func (h *MyHandler) StreamEvents(ctx context.Context) (io.ReadCloser, error) {
	// Server-side SSE: Create a pipe and write events
	pr, pw := io.Pipe()
	go func() {
		defer pw.Close()
		// Simulate events
		pw.Write([]byte("data: Event 1\n\n"))
		pw.Write([]byte("data: Event 2\n\n"))
	}()
	return pr, nil
}

// Usage: http.ListenAndServe(":8080", api.NewServer(&MyHandler{}))
```

## Ogen distinguishes itself with:

- **No Reflection or Dynamic Typing**: Pure code-generated JSON marshaling/unmarshaling for speeds up to GB/s, unlike oapi-codegen which relies on reflection leading to runtime overhead.
- **Static Radix Router**: Efficient routing for servers, outperforming dynamic routers in tools like OpenAPI Generator.
- **Sum Types for oneOf/anyOf**: Automatic type discrimination with tagged unions, reducing manual checks and errors.
- **Generic Wrappers for Optionals/Nullables**: Avoids pointer indirection pitfalls, minimizing GC pressure.
- **Built-in Validation and Error Handling**: Detailed, type-safe errors without extra libs.
- **Streaming Support**: Native for SSE/JSON streams, with low memory usage for large responses.
- **Extensibility**: Features like OpenTelemetry and custom extensions make it ideal for production.

Compared to alternatives:
- **oapi-codegen**: Simpler but slower due to reflection; lacks sum types.
- **OpenAPI Generator**: Broad language support but generates verbose, less performant Go code.
- **Trade-offs**: Ogen may require more spec annotations for full optimization, but yields superior runtime efficiency for high-throughput apps.

This makes ogen ideal for type-strict, performant APIs with real-time features like SSE.



| TUI Expected (from stubs/api.md) | Generated (from next-go/api/oas_client_gen.go) |
|----------------------------------|-----------------------------------------------|
| AppLog(ctx context.Context, params AppLogParams) error | AppLog(ctx context.Context, request OptAppLogReq, params AppLogParams) (bool, error) <br/> *Params: AppLogParams{Directory OptString}* |
| SessionGet(ctx context.Context, params SessionGetParams) (*Session, error) | SessionGet(ctx context.Context, params SessionGetParams) (*Session, error) <br/> *Params: SessionGetParams{Directory OptString, ID string}* |
| SessionChildren(ctx context.Context, params SessionChildrenParams) ([]*Session, error) | SessionChildren(ctx context.Context, params SessionChildrenParams) ([]Session, error) <br/> *Params: SessionChildrenParams{Directory OptString, ID string}* |
| SessionShare(ctx context.Context, params SessionShareParams) (*SessionShare, error) | SessionShare(ctx context.Context, params SessionShareParams) (*Session, error) <br/> *Params: SessionShareParams{Directory OptString, ID string}* <br/> *(Returns full Session, including Share)* |
| SessionUnshare(ctx context.Context, params SessionUnshareParams) error | SessionUnshare(ctx context.Context, params SessionUnshareParams) (*Session, error) <br/> *Params: SessionUnshareParams{Directory OptString, ID string}* |
| SessionRevert(ctx context.Context, params SessionRevertParams) (*SessionRevert, error) | SessionRevert(ctx context.Context, request OptSessionRevertReq, params SessionRevertParams) (*Session, error) <br/> *Params: SessionRevertParams{Directory OptString, ID string}* <br/> *(Body req for revert details; returns updated Session)* |
| SessionUnrevert(ctx context.Context, params SessionUnrevertParams) error | SessionUnrevert(ctx context.Context, params SessionUnrevertParams) (*Session, error) <br/> *Params: SessionUnrevertParams{Directory OptString, ID string}* |
| SessionNew(ctx context.Context, params SessionNewParams) (*Session, error) | SessionCreate(ctx context.Context, request OptSessionCreateReq, params SessionCreateParams) (SessionCreateRes, error) <br/> *Params: SessionCreateParams{Directory OptString}* <br/> *(Equivalent; body for create details, Res is Session or Error)* |
| SessionPrompt(ctx context.Context, params SessionPromptParams) (MessageUnion, error) | SessionPrompt(ctx context.Context, request OptSessionPromptReq, params SessionPromptParams) (*SessionPromptOK, error) <br/> *Params: SessionPromptParams{Directory OptString, ID string}* <br/> *(Body for prompt parts/model; returns AssistantMessage or similar)* |
| SessionInit(ctx context.Context, params SessionInitParams) error | SessionInit(ctx context.Context, request OptSessionInitReq, params SessionInitParams) (bool, error) <br/> *Params: SessionInitParams{Directory OptString, ID string}* |
| SessionSummarize(ctx context.Context, params SessionSummarizeParams) (string, error) | SessionSummarize(ctx context.Context, request OptSessionSummarizeReq, params SessionSummarizeParams) (bool, error) <br/> *Params: SessionSummarizeParams{Directory OptString, ID string}* <br/> *(Body optional; returns bool success, summary in session?)* |
| SessionCommand(ctx context.Context, params SessionCommandParams) (Command, error) | SessionCommand(ctx context.Context, request OptSessionCommandReq, params SessionCommandParams) (*SessionCommandOK, error) <br/> *Params: SessionCommandParams{Directory OptString, ID string}* <br/> *(Body for command; returns response with Command?)* |
| SessionShell(ctx context.Context, params SessionShellParams) error | SessionShell(ctx context.Context, request OptSessionShellReq, params SessionShellParams) (*AssistantMessage, error) <br/> *Params: SessionShellParams{Directory OptString, ID string}* <br/> *(Body for shell cmd; returns AssistantMessage)* |
| SessionAbort(ctx context.Context, params SessionAbortParams) error | SessionAbort(ctx context.Context, params SessionAbortParams) (bool, error) <br/> *Params: SessionAbortParams{Directory OptString, ID string}* |
| SessionList(ctx context.Context, params SessionListParams) ([]*Session, error) | SessionList(ctx context.Context, params SessionListParams) ([]Session, error) <br/> *Params: SessionListParams{Directory OptString}* |
| SessionDelete(ctx context.Context, params SessionDeleteParams) error | SessionDelete(ctx context.Context, params SessionDeleteParams) (bool, error) <br/> *Params: SessionDeleteParams{Directory OptString, ID string}* |
| SessionUpdate(ctx context.Context, params SessionUpdateParams) (*Session, error) | SessionUpdate(ctx context.Context, request OptSessionUpdateReq, params SessionUpdateParams) (*Session, error) <br/> *Params: SessionUpdateParams{Directory OptString, ID string}* <br/> *(Body for updates)* |
| SessionMessages(ctx context.Context, params SessionMessagesParams) ([]MessageUnion, error) | SessionMessages(ctx context.Context, params SessionMessagesParams) ([]SessionMessagesOKItem, error) <br/> *Params: SessionMessagesParams{Directory OptString, ID string}* <br/> *(Returns array of Messages, union of User/Assistant)* |
| SessionMessage(ctx context.Context, params SessionMessageParams) (MessageUnion, error) | SessionMessage(ctx context.Context, params SessionMessageParams) (*SessionMessageOK, error) <br/> *Params: SessionMessageParams{Directory OptString, ID string, MessageID string}* <br/> *(Returns single Message union)* |
| ConfigGet(ctx context.Context, params ConfigGetParams) (*Config, error) | *(No direct match; closest: ConfigProviders for providers/config)* <br/> ConfigProviders(ctx context.Context, params ConfigProvidersParams) (*ConfigProvidersOK, error) <br/> *Params: ConfigProvidersParams{Directory OptString}* <br/> *(Returns Providers and defaults; extend for full Config?)* |
| CommandList(ctx context.Context, params CommandListParams) ([]*Command, error) | CommandList(ctx context.Context, params CommandListParams) ([]Command, error) <br/> *Params: CommandListParams{Directory OptString}* |
| AppProviders(ctx context.Context, params AppProvidersParams) (*AppProvidersResponse, error) | ConfigProviders(ctx context.Context, params ConfigProvidersParams) (*ConfigProvidersOK, error) <br/> *Params: ConfigProvidersParams{Directory OptString}* <br/> *(Equivalent; returns []Provider with Models)* |
| AgentList(ctx context.Context, params AgentListParams) ([]*Agent, error) | *(No direct AgentList; providers include agents via Models? Closest: ConfigProviders or SessionCommand for agent ops)* |
| FindSymbols(ctx context.Context, params FindSymbolsParams) ([]*Symbol, error) | FindSymbols(ctx context.Context, params FindSymbolsParams) ([]Symbol, error) <br/> *Params: FindSymbolsParams{Directory OptString, Query string}* |
| FindFiles(ctx context.Context, params FindFilesParams) ([]*Path, error) | FindFiles(ctx context.Context, params FindFilesParams) ([]string, error) <br/> *Params: FindFilesParams{Directory OptString, Query string}* <br/> *(Returns paths as []string)* |
| FileStatus(ctx context.Context, params FileStatusParams) (*Path, error) | FileStatus(ctx context.Context, params FileStatusParams) ([]File, error) <br/> *Params: FileStatusParams{Directory OptString}* <br/> *(Returns []File with status)* |
| PathGet(ctx context.Context, params PathGetParams) (*Path, error) | PathGet(ctx context.Context, params PathGetParams) (*Path, error) <br/> *Params: PathGetParams{Directory OptString}* |
| ProjectCurrent(ctx context.Context, params ProjectCurrentParams) (*Project, error) | ProjectCurrent(ctx context.Context, params ProjectCurrentParams) (*Project, error) <br/> *Params: ProjectCurrentParams{Directory OptString}* |
| EventList(ctx context.Context, params EventListParams) ([]*EventListResponse, error) | EventSubscribe(ctx context.Context, params EventSubscribeParams) (EventSubscribeOK, error) <br/> *Params: EventSubscribeParams{Directory OptString}* <br/> *(Returns io.Reader for SSE stream; parse to EventListResponse unions)* |

**Notes**: 
- TUI expects simpler signatures (no OptReq bodies, direct returns like error/bool); generated includes context, optional request bodies for POST/PUT, and "Directory OptString" param (extra for workspace context, resolvable in SDK wrapper).
- Mismatches (e.g., SessionNew → SessionCreate; no direct AgentList/ConfigGet) need SDK facade to adapt/alias.
- Streaming (EventSubscribe) uses io.Reader for SSE, aligning with TUI's event needs via io.ReadCloser.
- Types (e.g., MessageUnion → sum types like Message{User/Assistant}; SessionShare → embedded in Session) are generated in oas_schemas_gen.go, matching stubs but with full fields (e.g., Agent{ID,Name,Type,State,Mode,Model}).
