// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/uri"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AppGet invokes app.get operation.
	//
	// Get app info.
	//
	// GET /app
	AppGet(ctx context.Context) (*App, error)
	// AppInit invokes app.init operation.
	//
	// Initialize the app.
	//
	// POST /app/init
	AppInit(ctx context.Context) (bool, error)
	// AppLog invokes app.log operation.
	//
	// Write a log entry to the server logs.
	//
	// POST /log
	AppLog(ctx context.Context, request OptAppLogReq) (bool, error)
	// AuthSet invokes auth.set operation.
	//
	// Set authentication credentials.
	//
	// PUT /auth/{id}
	AuthSet(ctx context.Context, request OptAuth, params AuthSetParams) (AuthSetRes, error)
	// CommandList invokes command.list operation.
	//
	// List all commands.
	//
	// GET /command
	CommandList(ctx context.Context) ([]Command, error)
	// ConfigProviders invokes config.providers operation.
	//
	// List all providers.
	//
	// GET /config/providers
	ConfigProviders(ctx context.Context) (*ConfigProvidersOK, error)
	// EventSubscribe invokes event.subscribe operation.
	//
	// Get events.
	//
	// GET /event
	EventSubscribe(ctx context.Context) (EventSubscribeOK, error)
	// FileRead invokes file.read operation.
	//
	// Read a file.
	//
	// GET /file
	FileRead(ctx context.Context, params FileReadParams) (*FileReadOK, error)
	// FileStatus invokes file.status operation.
	//
	// Get file status.
	//
	// GET /file/status
	FileStatus(ctx context.Context) ([]File, error)
	// FindFiles invokes find.files operation.
	//
	// Find files.
	//
	// GET /find/file
	FindFiles(ctx context.Context, params FindFilesParams) ([]string, error)
	// FindSymbols invokes find.symbols operation.
	//
	// Find workspace symbols.
	//
	// GET /find/symbol
	FindSymbols(ctx context.Context, params FindSymbolsParams) ([]Symbol, error)
	// FindText invokes find.text operation.
	//
	// Find text in files.
	//
	// GET /find
	FindText(ctx context.Context, params FindTextParams) ([]FindTextOKItem, error)
	// PostSessionByIdPermissionsByPermissionID invokes postSessionByIdPermissionsByPermissionID operation.
	//
	// Respond to a permission request.
	//
	// POST /session/{id}/permissions/{permissionID}
	PostSessionByIdPermissionsByPermissionID(ctx context.Context, request OptPostSessionByIdPermissionsByPermissionIDReq, params PostSessionByIdPermissionsByPermissionIDParams) (bool, error)
	// SessionAbort invokes session.abort operation.
	//
	// Abort a session.
	//
	// POST /session/{id}/abort
	SessionAbort(ctx context.Context, params SessionAbortParams) (bool, error)
	// SessionChat invokes session.chat operation.
	//
	// Create and send a new message to a session.
	//
	// POST /session/{id}/message
	SessionChat(ctx context.Context, request OptSessionChatReq, params SessionChatParams) (*SessionChatOK, error)
	// SessionChildren invokes session.children operation.
	//
	// Get a session's children.
	//
	// GET /session/{id}/children
	SessionChildren(ctx context.Context, params SessionChildrenParams) ([]Session, error)
	// SessionCommand invokes session.command operation.
	//
	// Send a new command to a session.
	//
	// POST /session/{id}/command
	SessionCommand(ctx context.Context, request OptSessionCommandReq, params SessionCommandParams) (*SessionCommandOK, error)
	// SessionCreate invokes session.create operation.
	//
	// Create a new session.
	//
	// POST /session
	SessionCreate(ctx context.Context, request OptSessionCreateReq) (SessionCreateRes, error)
	// SessionDelete invokes session.delete operation.
	//
	// Delete a session and all its data.
	//
	// DELETE /session/{id}
	SessionDelete(ctx context.Context, params SessionDeleteParams) (bool, error)
	// SessionGet invokes session.get operation.
	//
	// Get session.
	//
	// GET /session/{id}
	SessionGet(ctx context.Context, params SessionGetParams) (*Session, error)
	// SessionInit invokes session.init operation.
	//
	// Analyze the app and create an AGENTS.md file.
	//
	// POST /session/{id}/init
	SessionInit(ctx context.Context, request OptSessionInitReq, params SessionInitParams) (bool, error)
	// SessionList invokes session.list operation.
	//
	// List all sessions.
	//
	// GET /session
	SessionList(ctx context.Context) ([]Session, error)
	// SessionMessage invokes session.message operation.
	//
	// Get a message from a session.
	//
	// GET /session/{id}/message/{messageID}
	SessionMessage(ctx context.Context, params SessionMessageParams) (*SessionMessageOK, error)
	// SessionMessages invokes session.messages operation.
	//
	// List messages for a session.
	//
	// GET /session/{id}/message
	SessionMessages(ctx context.Context, params SessionMessagesParams) ([]SessionMessagesOKItem, error)
	// SessionRevert invokes session.revert operation.
	//
	// Revert a message.
	//
	// POST /session/{id}/revert
	SessionRevert(ctx context.Context, request OptSessionRevertReq, params SessionRevertParams) (*Session, error)
	// SessionShare invokes session.share operation.
	//
	// Share a session.
	//
	// POST /session/{id}/share
	SessionShare(ctx context.Context, params SessionShareParams) (*Session, error)
	// SessionShell invokes session.shell operation.
	//
	// Run a shell command.
	//
	// POST /session/{id}/shell
	SessionShell(ctx context.Context, request OptSessionShellReq, params SessionShellParams) (*AssistantMessage, error)
	// SessionSummarize invokes session.summarize operation.
	//
	// Summarize the session.
	//
	// POST /session/{id}/summarize
	SessionSummarize(ctx context.Context, request OptSessionSummarizeReq, params SessionSummarizeParams) (bool, error)
	// SessionUnrevert invokes session.unrevert operation.
	//
	// Restore all reverted messages.
	//
	// POST /session/{id}/unrevert
	SessionUnrevert(ctx context.Context, params SessionUnrevertParams) (*Session, error)
	// SessionUnshare invokes session.unshare operation.
	//
	// Unshare the session.
	//
	// DELETE /session/{id}/share
	SessionUnshare(ctx context.Context, params SessionUnshareParams) (*Session, error)
	// SessionUpdate invokes session.update operation.
	//
	// Update session properties.
	//
	// PATCH /session/{id}
	SessionUpdate(ctx context.Context, request OptSessionUpdateReq, params SessionUpdateParams) (*Session, error)
	// TuiAppendPrompt invokes tui.appendPrompt operation.
	//
	// Append prompt to the TUI.
	//
	// POST /tui/append-prompt
	TuiAppendPrompt(ctx context.Context, request OptTuiAppendPromptReq) (bool, error)
	// TuiClearPrompt invokes tui.clearPrompt operation.
	//
	// Clear the prompt.
	//
	// POST /tui/clear-prompt
	TuiClearPrompt(ctx context.Context) (bool, error)
	// TuiExecuteCommand invokes tui.executeCommand operation.
	//
	// Execute a TUI command (e.g. agent_cycle).
	//
	// POST /tui/execute-command
	TuiExecuteCommand(ctx context.Context, request OptTuiExecuteCommandReq) (bool, error)
	// TuiOpenHelp invokes tui.openHelp operation.
	//
	// Open the help dialog.
	//
	// POST /tui/open-help
	TuiOpenHelp(ctx context.Context) (bool, error)
	// TuiOpenModels invokes tui.openModels operation.
	//
	// Open the model dialog.
	//
	// POST /tui/open-models
	TuiOpenModels(ctx context.Context) (bool, error)
	// TuiOpenSessions invokes tui.openSessions operation.
	//
	// Open the session dialog.
	//
	// POST /tui/open-sessions
	TuiOpenSessions(ctx context.Context) (bool, error)
	// TuiOpenThemes invokes tui.openThemes operation.
	//
	// Open the theme dialog.
	//
	// POST /tui/open-themes
	TuiOpenThemes(ctx context.Context) (bool, error)
	// TuiShowToast invokes tui.showToast operation.
	//
	// Show a toast notification in the TUI.
	//
	// POST /tui/show-toast
	TuiShowToast(ctx context.Context, request OptTuiShowToastReq) (bool, error)
	// TuiSubmitPrompt invokes tui.submitPrompt operation.
	//
	// Submit the prompt.
	//
	// POST /tui/submit-prompt
	TuiSubmitPrompt(ctx context.Context) (bool, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AppGet invokes app.get operation.
//
// Get app info.
//
// GET /app
func (c *Client) AppGet(ctx context.Context) (*App, error) {
	res, err := c.sendAppGet(ctx)
	return res, err
}

func (c *Client) sendAppGet(ctx context.Context) (res *App, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/app"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppInit invokes app.init operation.
//
// Initialize the app.
//
// POST /app/init
func (c *Client) AppInit(ctx context.Context) (bool, error) {
	res, err := c.sendAppInit(ctx)
	return res, err
}

func (c *Client) sendAppInit(ctx context.Context) (res bool, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/app/init"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppInitResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppLog invokes app.log operation.
//
// Write a log entry to the server logs.
//
// POST /log
func (c *Client) AppLog(ctx context.Context, request OptAppLogReq) (bool, error) {
	res, err := c.sendAppLog(ctx, request)
	return res, err
}

func (c *Client) sendAppLog(ctx context.Context, request OptAppLogReq) (res bool, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/log"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppLogRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAppLogResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthSet invokes auth.set operation.
//
// Set authentication credentials.
//
// PUT /auth/{id}
func (c *Client) AuthSet(ctx context.Context, request OptAuth, params AuthSetParams) (AuthSetRes, error) {
	res, err := c.sendAuthSet(ctx, request, params)
	return res, err
}

func (c *Client) sendAuthSet(ctx context.Context, request OptAuth, params AuthSetParams) (res AuthSetRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/auth/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthSetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CommandList invokes command.list operation.
//
// List all commands.
//
// GET /command
func (c *Client) CommandList(ctx context.Context) ([]Command, error) {
	res, err := c.sendCommandList(ctx)
	return res, err
}

func (c *Client) sendCommandList(ctx context.Context) (res []Command, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/command"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCommandListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigProviders invokes config.providers operation.
//
// List all providers.
//
// GET /config/providers
func (c *Client) ConfigProviders(ctx context.Context) (*ConfigProvidersOK, error) {
	res, err := c.sendConfigProviders(ctx)
	return res, err
}

func (c *Client) sendConfigProviders(ctx context.Context) (res *ConfigProvidersOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/config/providers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigProvidersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EventSubscribe invokes event.subscribe operation.
//
// Get events.
//
// GET /event
func (c *Client) EventSubscribe(ctx context.Context) (EventSubscribeOK, error) {
	res, err := c.sendEventSubscribe(ctx)
	return res, err
}

func (c *Client) sendEventSubscribe(ctx context.Context) (res EventSubscribeOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/event"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEventSubscribeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FileRead invokes file.read operation.
//
// Read a file.
//
// GET /file
func (c *Client) FileRead(ctx context.Context, params FileReadParams) (*FileReadOK, error) {
	res, err := c.sendFileRead(ctx, params)
	return res, err
}

func (c *Client) sendFileRead(ctx context.Context, params FileReadParams) (res *FileReadOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/file"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "path" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFileReadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FileStatus invokes file.status operation.
//
// Get file status.
//
// GET /file/status
func (c *Client) FileStatus(ctx context.Context) ([]File, error) {
	res, err := c.sendFileStatus(ctx)
	return res, err
}

func (c *Client) sendFileStatus(ctx context.Context) (res []File, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/file/status"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFileStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindFiles invokes find.files operation.
//
// Find files.
//
// GET /find/file
func (c *Client) FindFiles(ctx context.Context, params FindFilesParams) ([]string, error) {
	res, err := c.sendFindFiles(ctx, params)
	return res, err
}

func (c *Client) sendFindFiles(ctx context.Context, params FindFilesParams) (res []string, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/find/file"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "query" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "query",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Query))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFindFilesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindSymbols invokes find.symbols operation.
//
// Find workspace symbols.
//
// GET /find/symbol
func (c *Client) FindSymbols(ctx context.Context, params FindSymbolsParams) ([]Symbol, error) {
	res, err := c.sendFindSymbols(ctx, params)
	return res, err
}

func (c *Client) sendFindSymbols(ctx context.Context, params FindSymbolsParams) (res []Symbol, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/find/symbol"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "query" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "query",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Query))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFindSymbolsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindText invokes find.text operation.
//
// Find text in files.
//
// GET /find
func (c *Client) FindText(ctx context.Context, params FindTextParams) ([]FindTextOKItem, error) {
	res, err := c.sendFindText(ctx, params)
	return res, err
}

func (c *Client) sendFindText(ctx context.Context, params FindTextParams) (res []FindTextOKItem, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/find"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pattern" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pattern",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Pattern))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFindTextResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostSessionByIdPermissionsByPermissionID invokes postSessionByIdPermissionsByPermissionID operation.
//
// Respond to a permission request.
//
// POST /session/{id}/permissions/{permissionID}
func (c *Client) PostSessionByIdPermissionsByPermissionID(ctx context.Context, request OptPostSessionByIdPermissionsByPermissionIDReq, params PostSessionByIdPermissionsByPermissionIDParams) (bool, error) {
	res, err := c.sendPostSessionByIdPermissionsByPermissionID(ctx, request, params)
	return res, err
}

func (c *Client) sendPostSessionByIdPermissionsByPermissionID(ctx context.Context, request OptPostSessionByIdPermissionsByPermissionIDReq, params PostSessionByIdPermissionsByPermissionIDParams) (res bool, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/session/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/permissions/"
	{
		// Encode "permissionID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "permissionID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PermissionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostSessionByIdPermissionsByPermissionIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostSessionByIdPermissionsByPermissionIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionAbort invokes session.abort operation.
//
// Abort a session.
//
// POST /session/{id}/abort
func (c *Client) SessionAbort(ctx context.Context, params SessionAbortParams) (bool, error) {
	res, err := c.sendSessionAbort(ctx, params)
	return res, err
}

func (c *Client) sendSessionAbort(ctx context.Context, params SessionAbortParams) (res bool, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/session/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/abort"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionAbortResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionChat invokes session.chat operation.
//
// Create and send a new message to a session.
//
// POST /session/{id}/message
func (c *Client) SessionChat(ctx context.Context, request OptSessionChatReq, params SessionChatParams) (*SessionChatOK, error) {
	res, err := c.sendSessionChat(ctx, request, params)
	return res, err
}

func (c *Client) sendSessionChat(ctx context.Context, request OptSessionChatReq, params SessionChatParams) (res *SessionChatOK, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/session/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/message"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSessionChatRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionChatResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionChildren invokes session.children operation.
//
// Get a session's children.
//
// GET /session/{id}/children
func (c *Client) SessionChildren(ctx context.Context, params SessionChildrenParams) ([]Session, error) {
	res, err := c.sendSessionChildren(ctx, params)
	return res, err
}

func (c *Client) sendSessionChildren(ctx context.Context, params SessionChildrenParams) (res []Session, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/session/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/children"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionChildrenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionCommand invokes session.command operation.
//
// Send a new command to a session.
//
// POST /session/{id}/command
func (c *Client) SessionCommand(ctx context.Context, request OptSessionCommandReq, params SessionCommandParams) (*SessionCommandOK, error) {
	res, err := c.sendSessionCommand(ctx, request, params)
	return res, err
}

func (c *Client) sendSessionCommand(ctx context.Context, request OptSessionCommandReq, params SessionCommandParams) (res *SessionCommandOK, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/session/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/command"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSessionCommandRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionCommandResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionCreate invokes session.create operation.
//
// Create a new session.
//
// POST /session
func (c *Client) SessionCreate(ctx context.Context, request OptSessionCreateReq) (SessionCreateRes, error) {
	res, err := c.sendSessionCreate(ctx, request)
	return res, err
}

func (c *Client) sendSessionCreate(ctx context.Context, request OptSessionCreateReq) (res SessionCreateRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/session"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSessionCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionDelete invokes session.delete operation.
//
// Delete a session and all its data.
//
// DELETE /session/{id}
func (c *Client) SessionDelete(ctx context.Context, params SessionDeleteParams) (bool, error) {
	res, err := c.sendSessionDelete(ctx, params)
	return res, err
}

func (c *Client) sendSessionDelete(ctx context.Context, params SessionDeleteParams) (res bool, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/session/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionGet invokes session.get operation.
//
// Get session.
//
// GET /session/{id}
func (c *Client) SessionGet(ctx context.Context, params SessionGetParams) (*Session, error) {
	res, err := c.sendSessionGet(ctx, params)
	return res, err
}

func (c *Client) sendSessionGet(ctx context.Context, params SessionGetParams) (res *Session, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/session/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionInit invokes session.init operation.
//
// Analyze the app and create an AGENTS.md file.
//
// POST /session/{id}/init
func (c *Client) SessionInit(ctx context.Context, request OptSessionInitReq, params SessionInitParams) (bool, error) {
	res, err := c.sendSessionInit(ctx, request, params)
	return res, err
}

func (c *Client) sendSessionInit(ctx context.Context, request OptSessionInitReq, params SessionInitParams) (res bool, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/session/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/init"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSessionInitRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionInitResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionList invokes session.list operation.
//
// List all sessions.
//
// GET /session
func (c *Client) SessionList(ctx context.Context) ([]Session, error) {
	res, err := c.sendSessionList(ctx)
	return res, err
}

func (c *Client) sendSessionList(ctx context.Context) (res []Session, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/session"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionMessage invokes session.message operation.
//
// Get a message from a session.
//
// GET /session/{id}/message/{messageID}
func (c *Client) SessionMessage(ctx context.Context, params SessionMessageParams) (*SessionMessageOK, error) {
	res, err := c.sendSessionMessage(ctx, params)
	return res, err
}

func (c *Client) sendSessionMessage(ctx context.Context, params SessionMessageParams) (res *SessionMessageOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/session/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/message/"
	{
		// Encode "messageID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "messageID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MessageID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionMessages invokes session.messages operation.
//
// List messages for a session.
//
// GET /session/{id}/message
func (c *Client) SessionMessages(ctx context.Context, params SessionMessagesParams) ([]SessionMessagesOKItem, error) {
	res, err := c.sendSessionMessages(ctx, params)
	return res, err
}

func (c *Client) sendSessionMessages(ctx context.Context, params SessionMessagesParams) (res []SessionMessagesOKItem, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/session/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/message"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionMessagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionRevert invokes session.revert operation.
//
// Revert a message.
//
// POST /session/{id}/revert
func (c *Client) SessionRevert(ctx context.Context, request OptSessionRevertReq, params SessionRevertParams) (*Session, error) {
	res, err := c.sendSessionRevert(ctx, request, params)
	return res, err
}

func (c *Client) sendSessionRevert(ctx context.Context, request OptSessionRevertReq, params SessionRevertParams) (res *Session, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/session/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/revert"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSessionRevertRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionRevertResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionShare invokes session.share operation.
//
// Share a session.
//
// POST /session/{id}/share
func (c *Client) SessionShare(ctx context.Context, params SessionShareParams) (*Session, error) {
	res, err := c.sendSessionShare(ctx, params)
	return res, err
}

func (c *Client) sendSessionShare(ctx context.Context, params SessionShareParams) (res *Session, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/session/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/share"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionShareResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionShell invokes session.shell operation.
//
// Run a shell command.
//
// POST /session/{id}/shell
func (c *Client) SessionShell(ctx context.Context, request OptSessionShellReq, params SessionShellParams) (*AssistantMessage, error) {
	res, err := c.sendSessionShell(ctx, request, params)
	return res, err
}

func (c *Client) sendSessionShell(ctx context.Context, request OptSessionShellReq, params SessionShellParams) (res *AssistantMessage, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/session/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/shell"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSessionShellRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionShellResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionSummarize invokes session.summarize operation.
//
// Summarize the session.
//
// POST /session/{id}/summarize
func (c *Client) SessionSummarize(ctx context.Context, request OptSessionSummarizeReq, params SessionSummarizeParams) (bool, error) {
	res, err := c.sendSessionSummarize(ctx, request, params)
	return res, err
}

func (c *Client) sendSessionSummarize(ctx context.Context, request OptSessionSummarizeReq, params SessionSummarizeParams) (res bool, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/session/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/summarize"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSessionSummarizeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionSummarizeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionUnrevert invokes session.unrevert operation.
//
// Restore all reverted messages.
//
// POST /session/{id}/unrevert
func (c *Client) SessionUnrevert(ctx context.Context, params SessionUnrevertParams) (*Session, error) {
	res, err := c.sendSessionUnrevert(ctx, params)
	return res, err
}

func (c *Client) sendSessionUnrevert(ctx context.Context, params SessionUnrevertParams) (res *Session, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/session/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/unrevert"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionUnrevertResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionUnshare invokes session.unshare operation.
//
// Unshare the session.
//
// DELETE /session/{id}/share
func (c *Client) SessionUnshare(ctx context.Context, params SessionUnshareParams) (*Session, error) {
	res, err := c.sendSessionUnshare(ctx, params)
	return res, err
}

func (c *Client) sendSessionUnshare(ctx context.Context, params SessionUnshareParams) (res *Session, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/session/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/share"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionUnshareResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SessionUpdate invokes session.update operation.
//
// Update session properties.
//
// PATCH /session/{id}
func (c *Client) SessionUpdate(ctx context.Context, request OptSessionUpdateReq, params SessionUpdateParams) (*Session, error) {
	res, err := c.sendSessionUpdate(ctx, request, params)
	return res, err
}

func (c *Client) sendSessionUpdate(ctx context.Context, request OptSessionUpdateReq, params SessionUpdateParams) (res *Session, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/session/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSessionUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSessionUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TuiAppendPrompt invokes tui.appendPrompt operation.
//
// Append prompt to the TUI.
//
// POST /tui/append-prompt
func (c *Client) TuiAppendPrompt(ctx context.Context, request OptTuiAppendPromptReq) (bool, error) {
	res, err := c.sendTuiAppendPrompt(ctx, request)
	return res, err
}

func (c *Client) sendTuiAppendPrompt(ctx context.Context, request OptTuiAppendPromptReq) (res bool, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tui/append-prompt"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTuiAppendPromptRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTuiAppendPromptResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TuiClearPrompt invokes tui.clearPrompt operation.
//
// Clear the prompt.
//
// POST /tui/clear-prompt
func (c *Client) TuiClearPrompt(ctx context.Context) (bool, error) {
	res, err := c.sendTuiClearPrompt(ctx)
	return res, err
}

func (c *Client) sendTuiClearPrompt(ctx context.Context) (res bool, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tui/clear-prompt"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTuiClearPromptResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TuiExecuteCommand invokes tui.executeCommand operation.
//
// Execute a TUI command (e.g. agent_cycle).
//
// POST /tui/execute-command
func (c *Client) TuiExecuteCommand(ctx context.Context, request OptTuiExecuteCommandReq) (bool, error) {
	res, err := c.sendTuiExecuteCommand(ctx, request)
	return res, err
}

func (c *Client) sendTuiExecuteCommand(ctx context.Context, request OptTuiExecuteCommandReq) (res bool, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tui/execute-command"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTuiExecuteCommandRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTuiExecuteCommandResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TuiOpenHelp invokes tui.openHelp operation.
//
// Open the help dialog.
//
// POST /tui/open-help
func (c *Client) TuiOpenHelp(ctx context.Context) (bool, error) {
	res, err := c.sendTuiOpenHelp(ctx)
	return res, err
}

func (c *Client) sendTuiOpenHelp(ctx context.Context) (res bool, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tui/open-help"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTuiOpenHelpResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TuiOpenModels invokes tui.openModels operation.
//
// Open the model dialog.
//
// POST /tui/open-models
func (c *Client) TuiOpenModels(ctx context.Context) (bool, error) {
	res, err := c.sendTuiOpenModels(ctx)
	return res, err
}

func (c *Client) sendTuiOpenModels(ctx context.Context) (res bool, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tui/open-models"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTuiOpenModelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TuiOpenSessions invokes tui.openSessions operation.
//
// Open the session dialog.
//
// POST /tui/open-sessions
func (c *Client) TuiOpenSessions(ctx context.Context) (bool, error) {
	res, err := c.sendTuiOpenSessions(ctx)
	return res, err
}

func (c *Client) sendTuiOpenSessions(ctx context.Context) (res bool, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tui/open-sessions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTuiOpenSessionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TuiOpenThemes invokes tui.openThemes operation.
//
// Open the theme dialog.
//
// POST /tui/open-themes
func (c *Client) TuiOpenThemes(ctx context.Context) (bool, error) {
	res, err := c.sendTuiOpenThemes(ctx)
	return res, err
}

func (c *Client) sendTuiOpenThemes(ctx context.Context) (res bool, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tui/open-themes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTuiOpenThemesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TuiShowToast invokes tui.showToast operation.
//
// Show a toast notification in the TUI.
//
// POST /tui/show-toast
func (c *Client) TuiShowToast(ctx context.Context, request OptTuiShowToastReq) (bool, error) {
	res, err := c.sendTuiShowToast(ctx, request)
	return res, err
}

func (c *Client) sendTuiShowToast(ctx context.Context, request OptTuiShowToastReq) (res bool, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tui/show-toast"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTuiShowToastRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTuiShowToastResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TuiSubmitPrompt invokes tui.submitPrompt operation.
//
// Submit the prompt.
//
// POST /tui/submit-prompt
func (c *Client) TuiSubmitPrompt(ctx context.Context) (bool, error) {
	res, err := c.sendTuiSubmitPrompt(ctx)
	return res, err
}

func (c *Client) sendTuiSubmitPrompt(ctx context.Context) (res bool, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tui/submit-prompt"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTuiSubmitPromptResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
