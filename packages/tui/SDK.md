# TUI SDK Plan and Structure

This document describes how the TUI will consume a newly generated Go SDK (using ogen), where the code will live, the generation workflow, and key decisions/features to leverage. It mirrors the structure and intent of packages/opencode/README.md, but tailored for the TUI and enriched with planning notes, ogen capabilities, and migration insights.

## Repository layout

Target structure after restructuring:

```text
packages/tui/
├── api/                  # OpenAPI spec and generated client
│   ├── generate.go
│   ├── openapi.json      # OpenAPI v3 spec (generated by the opencode bun server)
│   ├── openapi.yml       # OpenAPI v3 spec (our manually specified additions to the spec)
│   ├── ogen.yml          # Ogen configuration
│   └── ogen/             # Generated Go client code (DO NOT EDIT)
├── internal/             # existing TUI internals (components, layout, styles, theme, etc.)
│   ├── api/
│   ├── app/
│   │   ├── app.go
│   │   └── client/
│   │       └── client.go
│   ├── attachment/
│   ├── components/
│   ├── commands/
│   │   └── get.go
│   ├── layout/
│   ├── styles/
│   ├── theme/
│   ├── tui/              # Bubble Tea models/views
│   │   └── tui.go
│   └── ...
└── cmd/
    └── opencode/
        └── main.go
```

Notes:

- api/ogen is fully generated by ogen and should be excluded from linting that enforces local style rules when possible.
- Keep UI and app state in internal/ and cmd/tui/, not in the SDK.
- The app/app.go will orchestrate calls to api/ogen via app/client/client.go helpers for auth/retry.

## Build and run

- Go TUI build (similar to packages/opencode/README.md release path), example local build:


```
Optional: Convert to editable YAML for extensions (e.g., x-ogen-* for unions/validators; use jq for JSON->YAML):

```bash
jq -S . packages/tui/api/openapi.json > packages/tui/api/openapi.yaml  # Pretty-print to YAML # Edit openapi.yaml (e.g., add discriminators for Event oneOf, groups for Session/TUI paths) +```
+  Note: Ogen accepts both JSON/YAML directly (--spec ./openapi.json or ./openapi.yaml). Use YAML for customizations; JSON for fidelity to server.


```bash
cd packages/tui
CGO_ENABLED=0 go build -ldflags="-s -w -X main.Version=$(git describe --tags --always)" -o tui cmd/main.go
```

- During release, the opencode bundling step can still embed the TUI binary as before (see packages/opencode/README.md for reference build commands).

## SDK generation with ogen

- Use go:generate for reproducible SDK builds.
- Add a generate file:

```go
// filepath: packages/tui/api/generate.go
//go:build generate
// +build generate

package api

//go:generate sh -c "ogen --clean --config ./ogen.yml --target ./ogen --package api ./openapi.yaml"
```

- Provide an ogen.yml alongside openapi.yaml to configure generation (see Examples below).
- Commit openapi.yaml and ogen.yml. Commit generated code (ogen/) only if desired; otherwise, generate in CI and vendor artifacts.

## ogen configuration references

- Full config reference: https://github.com/ogen-go/ogen/blob/main/examples/_config/example_all.yml
- Features: https://ogen.dev/docs/features
- Extensions/customisation: https://ogen.dev/docs/extensions
- Sum Types: https://ogen.dev/docs/types/sumtype
- Optional Types: https://ogen.dev/docs/types/optional
- Streaming/SSE PR context: https://github.com/ogen-go/ogen/pull/1522 (inform implementation of event streams)

Key choices for this project:

- Authentication: Bearer auth via static token provider in app/client/client.go, wired into ogen client using WithRequestEditorFn or auth config in ogen.yml.
- Optional fields: Prefer ogen optional wrappers (e.g., optional.String) over custom helpers like opencode.F.
- Sum types: Enable discriminator-based unions where available in the schema; use discriminator inference when explicit tagging isn’t present.
- Streaming: Use the EventSubscribe endpoint returning an io.Reader-like stream. Ensure context cancellation cleanly tears down the stream; expose a Close helper in the wrapper if needed.
- Errors: Generate typed errors; wrap in a small adapter for consistent user-facing toasts.

Example ogen.yml (illustrative):

```yaml
# filepath: packages/tui/api/ogen.yml
compatibility:
  # prefer pointers for objects to reduce copies
  ptr-for-objects: true
features:
  std-errors: true
  client: true
  server: false
  models: true
http:
  client:
    # Inject Authorization: Bearer <token>
    request-editor: true
package: api
output:
  layout: flat
  # target directory is set by the generate command
```

## SSE and event handling

- The TUI consumes server-sent events (SSE) to update UI state. The generated client should:
  - Expose EventSubscribe(ctx) (or equivalent) that returns a streaming reader plus metadata.
  - Respect ctx cancellation for shutdown.
  - Optionally provide helpers to parse event lines into typed events to reduce custom parsing.
- Reference: PR 1522 discusses native SSE support paths; if native support is insufficient, keep a thin hand-written adapter in app/client that wraps the underlying http.Client and decodes events into generated types.

## What stays in the TUI vs. moves to SDK

Keep (UI/UX-specific):

- Bubble Tea components, layout, styles, theme, keybinds, debounce logic, leader sequences.
- State orchestration like switching between parent/child sessions before sending a prompt.

Move to SDK (or thin wrapper near SDK):

- All API request/response shapes, including optional fields, unions, enums.
- Permissions.Respond call, ToolIds/ToolList unions, and other service endpoints.
- Any manual JSON decoding for /tui/\* API paths in the app; replace with typed SDK calls.
- Event stream wire protocol and retry/backoff (if not native in ogen, put into app/client client.go wrapper once, not in UI code).

Result: TUI code only orchestrates and renders; SDK owns HTTP details.

## Migration checklist (from current opencode-sdk usage)

- Replace opencode.F optionals with ogen optional types.
- Update endpoints to ogen signatures (context-first, Opt\* request wrappers where generated).
- Adjust enum names/nesting where they differ (centralize mapping in app/client if needed).
- Ensure union handling uses generated IsX/AsX helpers (or type switches on generated sum types).
- Verify pointer vs value returns; update nil checks.
- Wire bearer auth and per-request logging/metrics in app/client.
- Validate EventSubscribe streaming works with cancellation and reconnection.

## Useful files while migrating

- TUI event/UI orchestration: packages/tui/internal/tui/tui.go
- App orchestrator and API usage: packages/opencode/internal/app/app.go
- Chat/message flows: packages/opencode/internal/components/chat/messages.go
- Current SDK analysis: packages/sdk/next-go/SDK.md

High-ROI refactors:

- Centralize all API invocations in app/app.go via a typed interface backed by the ogen client.
- Remove JSON body structs in tui.go for /tui/\*; call SDK methods directly.
- Introduce a small typed error adapter to map generated errors to user-friendly toasts.

## Development flow

- Generate the current spec: 
```bash
bun run dev generate > packages/tui/api/openapi.json
  OR IF THERE IS PROBLEMS WITH THE BUILD OF `bun run dev`
opencode generate > packages/tui/api/openapi.json
```

- Regenerate client:
```bash
cd packages/tui/api
go generate ./...
```

- Build and run TUI as usual to validate integration.
- CI: run go generate, build, lint, and tests; optionally commit generated code to keep release artifacts deterministic.

## Notes on schema design for better SDK ergonomics

- Prefer explicit discriminators for unions to get clean sum types.
- Use consistent naming for params/paths to reduce adapter code.
- Mark truly optional fields; avoid nullable where possible; prefer optional.\* wrappers.
- Define error responses as structured schemas so ogen can emit typed errors.

## Future work

- Add retries with backoff and jitter in app/client for flaky network/SSE.
- Add metrics/log hooks to the ogen client via RequestEditor and response middleware.
- Evaluate generating both server and client from the same spec in a spec-first flow.
